{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///SpeechRecognition.js","webpack:///webpack/bootstrap 6ecf3822046508a19cb4","webpack:///./src/SpeechRecognition.js","webpack:///./src/utils.js","webpack:///external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_2__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","SpeechRecognition","options","SpeechRecognitionInner","WrappedComponent","BrowserSpeechRecognition","window","webkitSpeechRecognition","mozSpeechRecognition","msSpeechRecognition","oSpeechRecognition","recognition","browserSupportsSpeechRecognition","isAndroid","test","navigator","userAgent","listening","autoStart","start","pauseAfterDisconnect","interimTranscript","finalTranscript","_Component","SpeechRecognitionContainer","props","_this","getPrototypeOf","disconnect","disconnectType","abort","stop","resetTranscript","setState","startListening","continuous","DOMException","abortListening","stopListening","interimResults","onresult","updateTranscript","bind","onend","onRecognitionDisconnect","updateFinalTranscript","_utils","debounce","state","_createClass","key","event","i","resultIndex","results","length","isFinal","confidence","transcript","concatTranscripts","newFinalTranscript","_len","arguments","transcriptParts","Array","_key","map","t","trim","join","_react2","createElement","_extends","Component","defineProperty","assign","target","source","hasOwnProperty","defineProperties","descriptor","protoProps","staticProps","_react","func","wait","immediate","timeout","context","args","later","apply","callNow","clearTimeout","setTimeout"],"mappings":"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","file":"SpeechRecognition.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SpeechRecognition\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"SpeechRecognition\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SpeechRecognition\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"SpeechRecognition\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\texports.default = SpeechRecognition;\n\t\n\tvar _react = __webpack_require__(2);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _utils = __webpack_require__(1);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tfunction SpeechRecognition(options) {\n\t  var SpeechRecognitionInner = function SpeechRecognitionInner(WrappedComponent) {\n\t    var BrowserSpeechRecognition = typeof window !== 'undefined' && (window.SpeechRecognition || window.webkitSpeechRecognition || window.mozSpeechRecognition || window.msSpeechRecognition || window.oSpeechRecognition);\n\t    var recognition = BrowserSpeechRecognition ? new BrowserSpeechRecognition() : null;\n\t    var browserSupportsSpeechRecognition = recognition !== null;\n\t    var isAndroid = /(android)/i.test(navigator.userAgent);\n\t    var listening = void 0;\n\t    if (!browserSupportsSpeechRecognition || options && options.autoStart === false) {\n\t      listening = false;\n\t    } else {\n\t      recognition.start();\n\t      listening = true;\n\t    }\n\t    var pauseAfterDisconnect = false;\n\t    var interimTranscript = '';\n\t    var finalTranscript = '';\n\t\n\t    return function (_Component) {\n\t      _inherits(SpeechRecognitionContainer, _Component);\n\t\n\t      function SpeechRecognitionContainer(props) {\n\t        _classCallCheck(this, SpeechRecognitionContainer);\n\t\n\t        var _this = _possibleConstructorReturn(this, (SpeechRecognitionContainer.__proto__ || Object.getPrototypeOf(SpeechRecognitionContainer)).call(this, props));\n\t\n\t        _this.disconnect = function (disconnectType) {\n\t          if (recognition) {\n\t            switch (disconnectType) {\n\t              case 'ABORT':\n\t                pauseAfterDisconnect = true;\n\t                recognition.abort();\n\t                break;\n\t              case 'RESET':\n\t                pauseAfterDisconnect = false;\n\t                recognition.abort();\n\t                break;\n\t              case 'STOP':\n\t              default:\n\t                pauseAfterDisconnect = true;\n\t                recognition.stop();\n\t            }\n\t          }\n\t        };\n\t\n\t        _this.resetTranscript = function () {\n\t          interimTranscript = '';\n\t          finalTranscript = '';\n\t          _this.disconnect('RESET');\n\t          _this.setState({ interimTranscript: interimTranscript, finalTranscript: finalTranscript });\n\t        };\n\t\n\t        _this.startListening = function () {\n\t          if (recognition && !listening) {\n\t            if (!recognition.continuous) {\n\t              _this.resetTranscript();\n\t            }\n\t            try {\n\t              recognition.start();\n\t            } catch (DOMException) {\n\t              // Tried to start recognition after it has already started - safe to swallow this error\n\t            }\n\t            listening = true;\n\t            _this.setState({ listening: listening });\n\t          }\n\t        };\n\t\n\t        _this.abortListening = function () {\n\t          listening = false;\n\t          _this.setState({ listening: listening });\n\t          _this.disconnect('ABORT');\n\t        };\n\t\n\t        _this.stopListening = function () {\n\t          listening = false;\n\t          _this.setState({ listening: listening });\n\t          _this.disconnect('STOP');\n\t        };\n\t\n\t        if (browserSupportsSpeechRecognition) {\n\t          recognition.continuous = options.continuous !== false;\n\t          recognition.interimResults = true;\n\t          recognition.onresult = _this.updateTranscript.bind(_this);\n\t          recognition.onend = _this.onRecognitionDisconnect.bind(_this);\n\t        }\n\t\n\t        if (isAndroid) {\n\t          _this.updateFinalTranscript = (0, _utils.debounce)(_this.updateFinalTranscript.bind(_this), 250, true);\n\t        }\n\t\n\t        _this.state = {\n\t          interimTranscript: interimTranscript,\n\t          finalTranscript: finalTranscript,\n\t          listening: listening\n\t        };\n\t        return _this;\n\t      }\n\t\n\t      _createClass(SpeechRecognitionContainer, [{\n\t        key: 'onRecognitionDisconnect',\n\t        value: function onRecognitionDisconnect() {\n\t          listening = false;\n\t          if (pauseAfterDisconnect) {\n\t            this.setState({ listening: listening });\n\t          } else if (recognition) {\n\t            if (recognition.continuous) {\n\t              this.startListening();\n\t            } else {\n\t              this.setState({ listening: listening });\n\t            }\n\t          }\n\t          pauseAfterDisconnect = false;\n\t        }\n\t      }, {\n\t        key: 'updateTranscript',\n\t        value: function updateTranscript(event) {\n\t          interimTranscript = '';\n\t          for (var i = event.resultIndex; i < event.results.length; ++i) {\n\t            if (event.results[i].isFinal && (!isAndroid || event.results[i][0].confidence > 0)) {\n\t              this.updateFinalTranscript(event.results[i][0].transcript);\n\t            } else {\n\t              interimTranscript = this.concatTranscripts(interimTranscript, event.results[i][0].transcript);\n\t            }\n\t          }\n\t          this.setState({ finalTranscript: finalTranscript, interimTranscript: interimTranscript });\n\t        }\n\t      }, {\n\t        key: 'updateFinalTranscript',\n\t        value: function updateFinalTranscript(newFinalTranscript) {\n\t          finalTranscript = this.concatTranscripts(finalTranscript, newFinalTranscript);\n\t        }\n\t      }, {\n\t        key: 'concatTranscripts',\n\t        value: function concatTranscripts() {\n\t          for (var _len = arguments.length, transcriptParts = Array(_len), _key = 0; _key < _len; _key++) {\n\t            transcriptParts[_key] = arguments[_key];\n\t          }\n\t\n\t          return transcriptParts.map(function (t) {\n\t            return t.trim();\n\t          }).join(' ').trim();\n\t        }\n\t      }, {\n\t        key: 'render',\n\t        value: function render() {\n\t          var transcript = this.concatTranscripts(finalTranscript, interimTranscript);\n\t\n\t          return _react2.default.createElement(WrappedComponent, _extends({\n\t            resetTranscript: this.resetTranscript,\n\t            startListening: this.startListening,\n\t            abortListening: this.abortListening,\n\t            stopListening: this.stopListening,\n\t            transcript: transcript,\n\t            recognition: recognition,\n\t            browserSupportsSpeechRecognition: browserSupportsSpeechRecognition\n\t          }, this.state, this.props));\n\t        }\n\t      }]);\n\t\n\t      return SpeechRecognitionContainer;\n\t    }(_react.Component);\n\t  };\n\t\n\t  if (typeof options === 'function') {\n\t    return SpeechRecognitionInner(options);\n\t  } else {\n\t    return SpeechRecognitionInner;\n\t  }\n\t}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar debounce = function debounce(func, wait, immediate) {\n\t  var timeout = void 0;\n\t  return function () {\n\t    var context = this,\n\t        args = arguments; // eslint-disable-line no-undef\n\t    var later = function later() {\n\t      timeout = null;\n\t      if (!immediate) func.apply(context, args);\n\t    };\n\t    var callNow = immediate && !timeout;\n\t    clearTimeout(timeout);\n\t    timeout = setTimeout(later, wait);\n\t    if (callNow) func.apply(context, args);\n\t  };\n\t};\n\t\n\texports.debounce = debounce;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n/***/ })\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// SpeechRecognition.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 6ecf3822046508a19cb4","import React, { Component } from 'react'\nimport { debounce } from './utils'\n\nexport default function SpeechRecognition(options) {\n  const SpeechRecognitionInner = function (WrappedComponent) {\n    const BrowserSpeechRecognition =\n      typeof window !== 'undefined' &&\n      (window.SpeechRecognition ||\n        window.webkitSpeechRecognition ||\n        window.mozSpeechRecognition ||\n        window.msSpeechRecognition ||\n        window.oSpeechRecognition)\n    const recognition = BrowserSpeechRecognition\n      ? new BrowserSpeechRecognition()\n      : null\n    const browserSupportsSpeechRecognition = recognition !== null\n    const isAndroid = /(android)/i.test(navigator.userAgent)\n    let listening\n    if (\n      !browserSupportsSpeechRecognition ||\n      (options && options.autoStart === false)\n    ) {\n      listening = false\n    } else {\n      recognition.start()\n      listening = true\n    }\n    let pauseAfterDisconnect = false\n    let interimTranscript = ''\n    let finalTranscript = ''\n\n    return class SpeechRecognitionContainer extends Component {\n      constructor(props) {\n        super(props)\n\n        if (browserSupportsSpeechRecognition) {\n          recognition.continuous = options.continuous !== false\n          recognition.interimResults = true\n          recognition.onresult = this.updateTranscript.bind(this)\n          recognition.onend = this.onRecognitionDisconnect.bind(this)\n        }\n\n        if (isAndroid) {\n          this.updateFinalTranscript = debounce(this.updateFinalTranscript.bind(this), 250, true)\n        }\n\n        this.state = {\n          interimTranscript,\n          finalTranscript,\n          listening\n        }\n      }\n\n      disconnect = disconnectType => {\n        if (recognition) {\n          switch (disconnectType) {\n            case 'ABORT':\n              pauseAfterDisconnect = true\n              recognition.abort()\n              break\n            case 'RESET':\n              pauseAfterDisconnect = false\n              recognition.abort()\n              break\n            case 'STOP':\n            default:\n              pauseAfterDisconnect = true\n              recognition.stop()\n          }\n        }\n      }\n\n      onRecognitionDisconnect() {\n        listening = false\n        if (pauseAfterDisconnect) {\n          this.setState({ listening })\n        } else if (recognition) {\n          if (recognition.continuous) {\n            this.startListening()\n          } else {\n            this.setState({ listening })\n          }\n        }\n        pauseAfterDisconnect = false\n      }\n\n      updateTranscript(event) {\n        interimTranscript = ''\n        for (let i = event.resultIndex; i < event.results.length; ++i) {\n          if (event.results[i].isFinal && (!isAndroid || event.results[i][0].confidence > 0)) {\n            this.updateFinalTranscript(event.results[i][0].transcript)\n          } else {\n            interimTranscript = this.concatTranscripts(\n              interimTranscript,\n              event.results[i][0].transcript\n            )\n          }\n        }\n        this.setState({ finalTranscript, interimTranscript })\n      }\n\n      updateFinalTranscript(newFinalTranscript) {\n        finalTranscript = this.concatTranscripts(\n          finalTranscript,\n          newFinalTranscript\n        )\n      }\n\n      concatTranscripts(...transcriptParts) {\n        return transcriptParts.map(t => t.trim()).join(' ').trim()\n      }\n\n      resetTranscript = () => {\n        interimTranscript = ''\n        finalTranscript = ''\n        this.disconnect('RESET')\n        this.setState({ interimTranscript, finalTranscript })\n      }\n\n      startListening = () => {\n        if (recognition && !listening) {\n          if (!recognition.continuous) {\n            this.resetTranscript()\n          }\n          try {\n            recognition.start()\n          } catch (DOMException) {\n            // Tried to start recognition after it has already started - safe to swallow this error\n          }\n          listening = true\n          this.setState({ listening })\n        }\n      }\n\n      abortListening = () => {\n        listening = false\n        this.setState({ listening })\n        this.disconnect('ABORT')\n      }\n\n      stopListening = () => {\n        listening = false\n        this.setState({ listening })\n        this.disconnect('STOP')\n      }\n\n      render() {\n        const transcript = this.concatTranscripts(\n          finalTranscript,\n          interimTranscript\n        )\n\n        return (\n          <WrappedComponent\n            resetTranscript={this.resetTranscript}\n            startListening={this.startListening}\n            abortListening={this.abortListening}\n            stopListening={this.stopListening}\n            transcript={transcript}\n            recognition={recognition}\n            browserSupportsSpeechRecognition={browserSupportsSpeechRecognition}\n            {...this.state}\n            {...this.props} />\n        )\n      }\n    }\n  }\n\n  if (typeof options === 'function') {\n    return SpeechRecognitionInner(options)\n  } else {\n    return SpeechRecognitionInner\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/SpeechRecognition.js","const debounce = (func, wait, immediate) => {\n  let timeout\n  return function() {\n    const context = this, args = arguments // eslint-disable-line no-undef\n    const later = function() {\n      timeout = null\n      if (!immediate) func.apply(context, args)\n    }\n    const callNow = immediate && !timeout\n    clearTimeout(timeout)\n    timeout = setTimeout(later, wait)\n    if (callNow) func.apply(context, args)\n  }\n}\n\nexport { debounce }\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}