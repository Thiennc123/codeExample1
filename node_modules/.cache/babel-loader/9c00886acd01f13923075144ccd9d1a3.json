{"ast":null,"code":"var wgs84 = require('wgs84');\n\nmodule.exports = function (_) {\n  if (_.type === 'Polygon') return polygonArea(_.coordinates);else if (_.type === 'MultiPolygon') {\n    var area = 0;\n\n    for (var i = 0; i < _.coordinates.length; i++) {\n      area += polygonArea(_.coordinates[i]);\n    }\n\n    return area;\n  } else {\n    return null;\n  }\n};\n\nfunction polygonArea(coords) {\n  var area = 0;\n\n  if (coords && coords.length > 0) {\n    area += Math.abs(ringArea(coords[0]));\n\n    for (var i = 1; i < coords.length; i++) {\n      area -= Math.abs(ringArea(coords[i]));\n    }\n  }\n\n  return area;\n}\n/**\n * Calculate the approximate area of the polygon were it projected onto\n *     the earth.  Note that this area will be positive if ring is oriented\n *     clockwise, otherwise it will be negative.\n *\n * Reference:\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n *     Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409\n *\n * Returns:\n * {float} The approximate signed geodesic area of the polygon in square\n *     meters.\n */\n\n\nfunction ringArea(coords) {\n  var area = 0;\n\n  if (coords.length > 2) {\n    var p1, p2;\n\n    for (var i = 0; i < coords.length - 1; i++) {\n      p1 = coords[i];\n      p2 = coords[i + 1];\n      area += rad(p2[0] - p1[0]) * (2 + Math.sin(rad(p1[1])) + Math.sin(rad(p2[1])));\n    }\n\n    area = area * wgs84.RADIUS * wgs84.RADIUS / 2;\n  }\n\n  return area;\n}\n\nfunction rad(_) {\n  return _ * Math.PI / 180;\n}","map":{"version":3,"sources":["/home/thiennc/projects/airagri-frontend/node_modules/geojson-area/index.js"],"names":["wgs84","require","module","exports","_","type","polygonArea","coordinates","area","i","length","coords","Math","abs","ringArea","p1","p2","rad","sin","RADIUS","PI"],"mappings":"AAAA,IAAIA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAAnB;;AAEAC,MAAM,CAACC,OAAP,GAAiB,UAASC,CAAT,EAAY;AACzB,MAAIA,CAAC,CAACC,IAAF,KAAW,SAAf,EAA0B,OAAOC,WAAW,CAACF,CAAC,CAACG,WAAH,CAAlB,CAA1B,KACK,IAAIH,CAAC,CAACC,IAAF,KAAW,cAAf,EAA+B;AAChC,QAAIG,IAAI,GAAG,CAAX;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,CAAC,CAACG,WAAF,CAAcG,MAAlC,EAA0CD,CAAC,EAA3C,EAA+C;AAC3CD,MAAAA,IAAI,IAAIF,WAAW,CAACF,CAAC,CAACG,WAAF,CAAcE,CAAd,CAAD,CAAnB;AACH;;AACD,WAAOD,IAAP;AACH,GANI,MAME;AACH,WAAO,IAAP;AACH;AACJ,CAXD;;AAaA,SAASF,WAAT,CAAqBK,MAArB,EAA6B;AACzB,MAAIH,IAAI,GAAG,CAAX;;AACA,MAAIG,MAAM,IAAIA,MAAM,CAACD,MAAP,GAAgB,CAA9B,EAAiC;AAC7BF,IAAAA,IAAI,IAAII,IAAI,CAACC,GAAL,CAASC,QAAQ,CAACH,MAAM,CAAC,CAAD,CAAP,CAAjB,CAAR;;AACA,SAAK,IAAIF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGE,MAAM,CAACD,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;AACpCD,MAAAA,IAAI,IAAII,IAAI,CAACC,GAAL,CAASC,QAAQ,CAACH,MAAM,CAACF,CAAD,CAAP,CAAjB,CAAR;AACH;AACJ;;AACD,SAAOD,IAAP;AACH;AAED;;;;;;;;;;;;;;;;AAcA,SAASM,QAAT,CAAkBH,MAAlB,EAA0B;AACtB,MAAIH,IAAI,GAAG,CAAX;;AAEA,MAAIG,MAAM,CAACD,MAAP,GAAgB,CAApB,EAAuB;AACnB,QAAIK,EAAJ,EAAQC,EAAR;;AACA,SAAK,IAAIP,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGE,MAAM,CAACD,MAAP,GAAgB,CAApC,EAAuCD,CAAC,EAAxC,EAA4C;AACxCM,MAAAA,EAAE,GAAGJ,MAAM,CAACF,CAAD,CAAX;AACAO,MAAAA,EAAE,GAAGL,MAAM,CAACF,CAAC,GAAG,CAAL,CAAX;AACAD,MAAAA,IAAI,IAAIS,GAAG,CAACD,EAAE,CAAC,CAAD,CAAF,GAAQD,EAAE,CAAC,CAAD,CAAX,CAAH,IAAsB,IAAIH,IAAI,CAACM,GAAL,CAASD,GAAG,CAACF,EAAE,CAAC,CAAD,CAAH,CAAZ,CAAJ,GAA2BH,IAAI,CAACM,GAAL,CAASD,GAAG,CAACD,EAAE,CAAC,CAAD,CAAH,CAAZ,CAAjD,CAAR;AACH;;AAEDR,IAAAA,IAAI,GAAGA,IAAI,GAAGR,KAAK,CAACmB,MAAb,GAAsBnB,KAAK,CAACmB,MAA5B,GAAqC,CAA5C;AACH;;AAED,SAAOX,IAAP;AACH;;AAED,SAASS,GAAT,CAAab,CAAb,EAAgB;AACZ,SAAOA,CAAC,GAAGQ,IAAI,CAACQ,EAAT,GAAc,GAArB;AACH","sourcesContent":["var wgs84 = require('wgs84');\n\nmodule.exports = function(_) {\n    if (_.type === 'Polygon') return polygonArea(_.coordinates);\n    else if (_.type === 'MultiPolygon') {\n        var area = 0;\n        for (var i = 0; i < _.coordinates.length; i++) {\n            area += polygonArea(_.coordinates[i]);\n        }\n        return area;\n    } else {\n        return null;\n    }\n};\n\nfunction polygonArea(coords) {\n    var area = 0;\n    if (coords && coords.length > 0) {\n        area += Math.abs(ringArea(coords[0]));\n        for (var i = 1; i < coords.length; i++) {\n            area -= Math.abs(ringArea(coords[i]));\n        }\n    }\n    return area;\n}\n\n/**\n * Calculate the approximate area of the polygon were it projected onto\n *     the earth.  Note that this area will be positive if ring is oriented\n *     clockwise, otherwise it will be negative.\n *\n * Reference:\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n *     Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409\n *\n * Returns:\n * {float} The approximate signed geodesic area of the polygon in square\n *     meters.\n */\nfunction ringArea(coords) {\n    var area = 0;\n\n    if (coords.length > 2) {\n        var p1, p2;\n        for (var i = 0; i < coords.length - 1; i++) {\n            p1 = coords[i];\n            p2 = coords[i + 1];\n            area += rad(p2[0] - p1[0]) * (2 + Math.sin(rad(p1[1])) + Math.sin(rad(p2[1])));\n        }\n\n        area = area * wgs84.RADIUS * wgs84.RADIUS / 2;\n    }\n\n    return area;\n}\n\nfunction rad(_) {\n    return _ * Math.PI / 180;\n}\n"]},"metadata":{},"sourceType":"script"}